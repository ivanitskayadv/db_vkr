CREATE OR REPLACE VIEW PUBLIC.V_PHONE_LIST
AS
SELECT E.EMP_NO,
       E.FIRST_NAME,
       E.LAST_NAME,
       E.PHONE_EXT,
       D.LOCATION,
       D.PHONE_NO
  FROM TBL_EMPLOYEE E,
       TBL_DEPARTMENT D
 WHERE E.DEPT_NO = D.DEPT_NO;
 
CREATE OR REPLACE PROCEDURE PUBLIC.SP_ADD_EMP_PROJ(
  EMP_NO SMALLINT, PROJ_ID CHARACTER) 
LANGUAGE plpgsql
AS $PROCEDURE$
BEGIN
  INSERT INTO
  TBL_EMPLOYEE_PROJECT (
    EMP_NO, 
    PROJ_ID
  ) VALUES (
    EMP_NO, 
    PROJ_ID
  );
  EXCEPTION
    WHEN FOREIGN_KEY_VIOLATION THEN 
      RAISE FOREIGN_KEY_VIOLATION USING DETAIL = 'UNKNOWN EMPLOYEE ID';
END;
$PROCEDURE$;

-----------------------------------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE public.sp_add_emp_proj(IN emp_no smallint, IN proj_id character)
 LANGUAGE plpgsql
AS $procedure$
BEGIN
  INSERT INTO
  TBL_EMPLOYEE_PROJECT (
    EMP_NO, 
    PROJ_ID
  ) VALUES (
    EMP_NO, 
    PROJ_ID
  );
  EXCEPTION
    WHEN FOREIGN_KEY_VIOLATION THEN 
      RAISE FOREIGN_KEY_VIOLATION USING DETAIL = 'Invalid employee number or project id.';
END;
$procedure$;


CREATE OR REPLACE FUNCTION PUBLIC.FN_ALL_LANGS() 
RETURNS TABLE (
  CODE CHARACTER VARYING,
  GRADE SMALLINT,
  COUNTRY CHARACTER VARYING,
  LANG CHARACTER VARYING
) LANGUAGE plpgsql AS 
$FUNCTION$
DECLARE
  T_CODE    VARCHAR(5);
  T_GRADE   INT2;
  T_COUNTRY VARCHAR(15);
BEGIN
  FOR T_CODE, T_GRADE, T_COUNTRY IN
      SELECT JOB_CODE,
             JOB_GRADE,
             JOB_COUNTRY
        FROM TBL_JOB 
  LOOP
    FOR CODE, GRADE, COUNTRY, LANG IN
      SELECT J_CODE,
             J_GRADE,
             J_COUNTRY,
             LANGUAGES
        FROM (SELECT FN_SHOW_LANGS(T_CODE, T_GRADE, T_COUNTRY)) T_TABLE
    LOOP
      RETURN NEXT;
    END LOOP;
  END LOOP;
RETURN;
END $FUNCTION$;

CREATE OR REPLACE PROCEDURE PUBLIC.SP_DELETE_EMPLOYEE(IN_EMP_NUM INTEGER)
 LANGUAGE PLPGSQL
AS $PROCEDURE$
DECLARE 
  ANY_SALES INTEGER;
BEGIN
  /*
   *  IF THERE ARE ANY SALES RECORDS REFERENCING THIS EMPLOYEE,
   *  CAN'T DELETE THE EMPLOYEE UNTIL THE SALES ARE RE-ASSIGNED
   *  TO ANOTHER EMPLOYEE OR CHANGED TO NULL.
   */
  SELECT COUNT(PO_NUMBER)
    INTO ANY_SALES
    FROM SALES
   WHERE SALES_REP = IN_EMP_NUM;
  
  IF (ANY_SALES > 0) THEN
    RAISE EXCEPTION 'Reassign the sales records before deleting this employee.';
  END IF;
-- IF THE EMPLOYEE IS A MANAGER, UPDATE THE DEPARTMENT.;
  UPDATE DEPARTMENT
     SET MNGR_NO = NULL
   WHERE MNGR_NO = IN_EMP_NUM;
-- IF THE EMPLOYEE IS A PROJECT LEADER, UPDATE PROJECT.;
  UPDATE PROJECT
     SET TEAM_LEADER = NULL
   WHERE TEAM_LEADER = IN_EMP_NUM;
  -- DELETE THE EMPLOYEE FROM ANY PROJECTS.
  DELETE FROM EMPLOYEE_PROJECT
   WHERE EMP_NO = IN_EMP_NUM;
-- DELETE OLD SALARY RECORDS.
  DELETE FROM SALARY_HISTORY 
   WHERE EMP_NO = IN_EMP_NUM;
-- DELETE THE EMPLOYEE.
  DELETE FROM EMPLOYEE 
   WHERE EMP_NO = IN_EMP_NUM;
END;
$PROCEDURE$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_DEPT_BUDGET(IN_DNO CHARACTER VARYING)
 RETURNS NUMERIC
 LANGUAGE SQL
AS $FUNCTION$
  SELECT SUM( CASE
                  WHEN DEPT_NO = IN_DNO
                    THEN BUDGET
                  ELSE FN_DEPT_BUDGET(DEPT_NO::VARCHAR)
              END
            ):: DECIMAL(12, 2)
    FROM TBL_DEPARTMENT
   WHERE DEPT_NO = IN_DNO
      OR HEAD_DEPT = IN_DNO ;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_GET_EMP_PROJ(EMP_NUM SMALLINT)
  RETURNS TABLE(PROJECT_ID CHAR)
  LANGUAGE plpgsql
AS $FUNCTION$
BEGIN
  FOR PROJECT_ID IN 
    SELECT PROJ_ID
      FROM TBL_EMPLOYEE_PROJECT
     WHERE MP_NO = EMP_NUM
  LOOP
    RETURN NEXT;
  END LOOP;
END;
$FUNCTION$;

CREATE OR REPLACE PROCEDURE PUBLIC.SP_MAIL_LABEL(
  CUST_NUM INTEGER,
  OUT LINE1 CHARACTER,
  OUT LINE2 CHARACTER,
  OUT LINE3 CHARACTER,
  OUT LINE4 CHARACTER,
  OUT LINE5 CHARACTER,
  OUT LINE6 CHARACTER
) LANGUAGE plpgsql
AS $PROCEDURE$
DECLARE 
  CUST VARCHAR(30);
  FIRST_NAME VARCHAR(15);
  LAST_NAME VARCHAR(20);
  ADDR1 VARCHAR(30);
  ADDR2 VARCHAR(30);
  CTY VARCHAR(25);
  STATE VARCHAR(15);
  CNTRY VARCHAR(15);
  POSTCODE VARCHAR(12);
BEGIN
  LINE1 := '';
  LINE2 := '';
  LINE3 := '';
  LINE4 := '';
  LINE5 := '';
  LINE6 := '';
  SELECT CUSTOMER, 
         CONTACT_FIRST, 
         CONTACT_LAST, 
         ADDRESS_LINE1,
         ADDRESS_LINE2, 
         CITY, 
         STATE_PROVINCE, 
         COUNTRY, 
         POSTAL_CODE
    INTO CUST, 
         FIRST_NAME, 
         LAST_NAME, 
         ADDR1, 
         ADDR2,
         CTY, 
         STATE, 
         CNTRY, 
         POSTCODE
    FROM TBL_CUSTOMER
   WHERE CUST_NO = CUST_NUM;

  IF CUST IS NOT NULL THEN
    LINE1 := CUST;
  END IF;
  
  IF FIRST_NAME IS NOT NULL THEN
    LINE2 := FIRST_NAME || ' ' || LAST_NAME;
  ELSE
    LINE2 := LAST_NAME;
  END IF;
  
  IF ADDR1 IS NOT NULL THEN
    LINE3 := ADDR1;
  END IF;
  
  IF ADDR2 IS NOT NULL THEN
    LINE4 := ADDR2;
  END IF;
  
  IF CNTRY = ' USA' THEN
      IF CTY IS NOT NULL THEN
        LINE5 := CTY || ', ' || STATE || ' ' || POSTCODE;
      ELSE
        LINE5 := STATE || ' ' || POSTCODE;
      END IF;
  ELSE
      IF CTY IS NOT NULL THEN
        LINE5 := CTY || ', ' || STATE;
      ELSE
        LINE5 := STATE;
        LINE6 := CNTRY || ' ' || POSTCODE;
      END IF;
  END IF;
END;
$PROCEDURE$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_NOTICE_EVENT()
 RETURNS TRIGGER
 LANGUAGE PLPGSQL
AS $FUNCTION$
BEGIN 
  IF OLD.ORDER_STATUS IS NULL THEN
    NEW.ORDER_STATUS := ' new_order';
  END IF;
  RETURN NEW;
END;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_ORG_CHART()
 RETURNS TABLE(
  HEAD_DEP CHARACTER,
  DEPT CHARACTER,
  MNGR_NAME CHARACTER,
  TITLE CHARACTER,
  EMP_CNT INTEGER
) LANGUAGE PLPGSQL
AS $FUNCTION$
DECLARE 
  MNGR_NUM INTEGER;
  DNO CHAR(3);
BEGIN
  FOR HEAD_DEP,
      DEPT,
      MNGR_NUM,
      DNO IN
      SELECT H.DEPARTMENT,
             D.DEPARTMENT,
             D.MNGR_NO,
             D.DEPT_NO
        FROM DEPARTMENT D
        LEFT JOIN DEPARTMENT H 
          ON D.HEAD_DEPT = H.DEPT_NO
       ORDER BY D.DEPT_NO LOOP
  IF MNGR_NUM IS NULL THEN
    MNGR_NAME := '--TBH--';
    TITLE := '';
  ELSE
     SELECT FULL_NAME, 
            JOB_CODE
       INTO MNGR_NAME, 
            TITLE
       FROM EMPLOYEE
      WHERE EMP_NO = MNGR_NUM;
  END IF;
  
  SELECT COUNT(EMP_NO)
    INTO EMP_CNT
    FROM EMPLOYEE
   WHERE DEPT_NO = DNO;
 
  RETURN NEXT;
  END LOOP;
  END;
$FUNCTION$;

CREATE OR REPLACE PROCEDURE PUBLIC.SP_SHIP_ORDER(IN_PO_NUM CHARACTER)
LANGUAGE PLPGSQL
AS $PROCEDURE$ 
DECLARE 
  ORD_STAT CHAR(7);
  HOLD_STAT CHAR(1);
  CUST_NUM INTEGER;
  ANY_PO CHAR(8);
BEGIN
  SELECT S.ORDER_STATUS, C.ON_HOLD, C.CUST_NO
    INTO ORD_STAT, HOLD_STAT, CUST_NUM
    FROM SALES S
    JOIN CUSTOMER C
      ON C.CUST_NO = S.CUST_NO
   WHERE PO_NUMBER = PO_NUM;

/* THIS PURCHASE ORDER HAS BEEN ALREADY SHIPPED. */
  IF ORD_STAT = 'shipped' THEN
    RAISE EXCEPTION 'Order status is "shipped."';
/*  CUSTOMER IS ON HOLD. */
  ELSEIF HOLD_STAT = '*' THEN
    RAISE EXCEPTION 'This customer is on hold.';
  END IF;

  /*  IF THERE IS AN UNPAID BALANCE ON ORDERS SHIPPED OVER 2 MONTHS AGO,
   *  PUT THE CUSTOMER ON HOLD.*/
  FOR ANY_PO IN 
    SELECT PO_NUMBER
      FROM SALES
     WHERE CUST_NO = CUST_NUM
       AND ORDER_STATUS = 'shipped'
       AND PAID = 'n'
       AND SHIP_DATE < NOW()::TIMESTAMP 
   LOOP 
     RAISE EXCEPTION 'Overdue balance -- can not ship.';
     UPDATE CUSTOMER
        SET ON_HOLD = '*'
      WHERE CUST_NO = CUST_NUM; 
   END LOOP;

  --SHIP THE ORDER.
   UPDATE SALES
      SET ORDER_STATUS = 'shipped', 
          SHIP_DATE = 'now'
    WHERE PO_NUMBER = IN_PO_NUM;
END; 
$PROCEDURE$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_SHOW_LANGS(CODE CHARACTER VARYING, GRADE SMALLINT, CTY CHARACTER VARYING)
RETURNS TABLE(
  J_CODE CHARACTER VARYING, 
  J_GRADE SMALLINT, 
  J_COUNTRY CHARACTER VARYING, 
  LANGUAGES CHARACTER VARYING
) LANGUAGE PLPGSQL
AS $FUNCTION$
DECLARE 
  TEMP_ARRAY TEXT[];
BEGIN
  SELECT JOB_CODE, 
         JOB_GRADE, 
         JOB_COUNTRY, 
         LANGUAGE_REQ
    INTO J_CODE, 
         J_GRADE, 
         J_COUNTRY, 
         TEMP_ARRAY
    FROM JOB
   WHERE(JOB_CODE = CODE AND JOB_GRADE = GRADE AND JOB_COUNTRY = CTY AND LANGUAGE_REQ IS NOT NULL);

  FOREACH LANGUAGES IN ARRAY TEMP_ARRAY LOOP
    RETURN NEXT;
  END LOOP;
END;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_SUB_TOT_BUDGET(HEAD_DEP CHARACTER VARYING)
 RETURNS TABLE(
  TOT_BUDGET NUMERIC, 
  AVG_BUDGET NUMERIC, 
  MIN_BUDGET NUMERIC, 
  MAX_BUDGET NUMERIC
) LANGUAGE PLPGSQL
AS $FUNCTION$
BEGIN
  RETURN QUERY 
    SELECT SUM(BUDGET), 
           AVG(BUDGET), 
           MIN(BUDGET), 
           MAX(BUDGET)
      FROM DEPARTMENT
     WHERE HEAD_DEPT = HEAD_DEP;
END;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_SET_CUST_NO()
 RETURNS TRIGGER
 LANGUAGE PLPGSQL
AS $FUNCTION$
BEGIN 
  IF NEW.CUST_NO IS NULL THEN
    NEW.CUST_NO := NEXTVAL('SERIAL_CUST_NO');
  END IF;
  RETURN NEW;
END;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_SET_EMP_NO()
 RETURNS TRIGGER
 LANGUAGE PLPGSQL
AS $FUNCTION$
BEGIN 
  IF (NEW.EMP_NO IS NULL) THEN
    NEW.EMP_NO := NEXTVAL('SERIAL_EMP_NO');
  END IF;
  RETURN NEW;
END;
$FUNCTION$;

CREATE OR REPLACE FUNCTION PUBLIC.FN_SSH()
 RETURNS TRIGGER
 LANGUAGE PLPGSQL
AS $FUNCTION$
BEGIN 
  IF (OLD.SALARY <> NEW.SALARY) THEN
    INSERT INTO SALARY_HISTORY (
      EMP_NO, 
      CHANGE_DATE, 
      UPDATER_ID, 
      OLD_SALARY, 
      PERCENT_CHANGE
    ) VALUES (
      OLD.EMP_NO, 
      'now', 
      USER, 
      OLD.SALARY,
      (NEW.SALARY - OLD.SALARY) * 100 / OLD.SALARY
    );
  END IF;
END;
$FUNCTION$;

--------------------------------------------------------- TRIGGERS
CREATE TRIGGER TG_SET_CUST_NO 
  BEFORE INSERT
  ON PUBLIC.TBL_CUSTOMER 
  FOR EACH ROW EXECUTE FUNCTION FN_SET_CUST_NO();

CREATE TRIGGER TG_SAVE_SALARY_CHANGE 
  AFTER UPDATE
  ON PUBLIC.TBL_EMPLOYEE 
FOR EACH ROW EXECUTE FUNCTION FN_SSH();

CREATE TRIGGER TG_SET_EMP_NO 
  BEFORE INSERT
  ON PUBLIC.TBL_EMPLOYEE 
FOR EACH ROW EXECUTE FUNCTION FN_SET_EMP_NO();

CREATE TRIGGER TG_POST_NEW_ORDER 
  BEFORE INSERT
  ON PUBLIC.TBL_SALES 
  FOR EACH ROW EXECUTE FUNCTION FN_NOTICE_EVENT();
